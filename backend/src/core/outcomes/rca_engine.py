"""
Root Cause Synthesizer - Counterfactual analysis for incident resolution.

Uses "If I hadn't taken Action X, would the system have crashed?" logic
to determine root causes from replay buffers.
"""

from __future__ import annotations

import logging
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional
from datetime import datetime

from backend.src.core.autonomy.loop import ReplayEntry

logger = logging.getLogger(__name__)


@dataclass
class RootCauseReport:
    """Report generated by the Root Cause Synthesizer."""
    incident_id: str
    root_cause_action_index: int
    confidence: float
    reasoning: str
    counterfactuals: List[str]
    timeline: List[str]


class RootCauseSynthesizer:
    """
    Analyzes incident history to find root causes.

    Methods:
    - Temporal Analysis: What happened right before the failure?
    - Pattern Matching: Do we recognize this sequence of events?
    - Counterfactual Simulation: (Simplified) "What if we skipped this?"
    """

    def analyze(self, incident_id: str, history: List[ReplayEntry]) -> Optional[RootCauseReport]:
        """
        Analyze a sequence of events to determine the root cause of a failure.

        Assumption: The last entry in history represents the failure state or the point where
        we realized something was wrong.
        """
        if not history:
            return None

        # 1. Identify the failure point
        # Look for the last failed action or an observation indicating failure
        failure_index = -1
        for i, entry in enumerate(reversed(history)):
            outcome = entry.outcome
            if not outcome.get("success", True):
                failure_index = len(history) - 1 - i
                break

        if failure_index == -1:
            # Maybe the observation indicates failure?
            # For now, if no action failed, we might assume the system state was bad.
            # We'll take the last action as the starting point.
            failure_index = len(history) - 1

        failed_entry = history[failure_index]

        # 2. Causal traceback
        # We look for the action that likely caused this.
        # Simple heuristic: The action immediately preceding the failure is the prime suspect.
        # But if it's a "check" action (like get_logs), it's likely not the cause.

        suspect_index = failure_index
        suspect_entry = failed_entry

        # Walk back to find a "state-changing" action
        # We assume actions starting with 'get', 'list', 'check', 'read' are safe (read-only)
        # We start looking from the action *before* the failure, to find what led to this.
        # Unless the failed action was the first one.

        start_search = failure_index - 1

        for i in range(start_search, -1, -1):
            entry = history[i]
            tool_name = entry.action.get("tool", "")
            if not self._is_read_only(tool_name):
                suspect_index = i
                suspect_entry = entry
                break

        # 3. Counterfactual reasoning
        # "If we hadn't done {suspect_tool}, would {failed_tool} have failed?"

        confidence = 0.5
        reasoning = []
        counterfactuals = []

        if suspect_index == failure_index:
            # The failed action itself is the cause (e.g., bad args)
            reasoning.append(f"Action '{suspect_entry.action.get('tool')}' failed directly.")
            confidence = 0.9
            counterfactuals.append(
                f"If '{suspect_entry.action.get('tool')}' had valid arguments, it might have succeeded."
            )
        else:
            # A previous action caused the failure
            reasoning.append(
                f"Action '{suspect_entry.action.get('tool')}' (index {suspect_index}) modified state, "
                f"likely causing '{failed_entry.action.get('tool')}' (index {failure_index}) to fail."
            )
            confidence = 0.7
            counterfactuals.append(
                f"If action '{suspect_entry.action.get('tool')}' was skipped, state would remain unchanged."
            )

        # Generate timeline
        timeline = []
        for i, entry in enumerate(history):
            marker = ""
            if i == suspect_index: marker = " [ROOT CAUSE?]"
            if i == failure_index: marker = " [FAILURE]"
            timestamp = entry.timestamp.strftime("%H:%M:%S")
            tool = entry.action.get("tool")
            timeline.append(f"{timestamp} - {tool}{marker}")

        return RootCauseReport(
            incident_id=incident_id,
            root_cause_action_index=suspect_index,
            confidence=confidence,
            reasoning="\n".join(reasoning),
            counterfactuals=counterfactuals,
            timeline=timeline
        )

    def _is_read_only(self, tool_name: str) -> bool:
        """Heuristic to check if a tool is read-only."""
        prefixes = ["get", "list", "check", "read", "show", "describe", "status"]
        return any(tool_name.startswith(p) for p in prefixes)


# Global instance
rca_engine = RootCauseSynthesizer()
